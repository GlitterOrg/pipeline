<html>
  <head>
    <script src='../bower_components/web-animations-next/web-animations-forced.min.js'></script>
    <link rel="import" href="../src/css-poly.html">
    <script src="../bower_components/closure-library/closure/goog/base.js"></script>
    <script src="../src/deps.js"></script>
    <script src='../src/glitter.js'></script>
    <script>goog.require('paint');</script>
  </head>
  <body>
    <div style="width: 100px; height: 100px; cursor: pointer; display: inline-block; color: #666; font-size:14px; background: #fafafa; box-shadow: 0 2px 10px 0 rgba(0,0,0,.16); border-radius: 3px; -webkit-user-select: none;">BUTTON</div>
    <script>
      var WAVE_MAX_R = 150;

      registerPropertyHandler('waveRadius', {
        animateAs: 'list<number>'
      });
      registerPropertyHandler('waveOpacity', {
        animateAs: 'list<number>'
      });

      var waveRadiusFn = function(time, ww, hh) {
        var waveRadius = Math.min(Math.sqrt(ww * ww + hh * hh), WAVE_MAX_R) * 1.1 + 5;
        var duration = 1.1 - .2 * (waveRadius / WAVE_MAX_R);
        var tt = (time / duration);
        var size = waveRadius * (1 - Math.pow(80, -tt));
        return Math.abs(size);
      };

      var OPACITY_INITIAL = 0.25;
      var OPACITY_DECAY = 0.8;

      var waveOpacityFn = function(time) {
        return Math.max(0, OPACITY_INITIAL - time * OPACITY_DECAY);
      };

      var cX;
      var cY;
      var animTime;
      var hasRaf;
      var waves = [];
      var op;
      var rp;
      var kf;

      var el = document.body.children[0];

      el.onBackground = function(ctx) {
        var w = ctx.width;
        var h = ctx.height;
        var remove = [];

        if (el.style.waveRadius) {
          var rTimes = el.style.waveRadius.split(' ').map(Number);
        }
        if (el.style.waveOpacity) {
          var oTimes = el.style.waveOpacity.split(' ').map(Number);
        }

        //console.log(waves, rTimes, oTimes);

        for (var i = 0; i < waves.length; i++) {
          var wave = waves[i];

          var radius = waveRadiusFn(rTimes ? rTimes[i] : 0, w, h);
          var waveAlpha = waveOpacityFn(oTimes ? oTimes[i] : 0);

          ctx.setCompositeOperation('darken');
          ctx.setFillColor('rgba(0,255,255,'+waveAlpha+')');
          ctx.beginPath();
          ctx.arc(wave['cX'], wave['cY'], radius, 0, Math.PI * 2);
          ctx.fill();

          if (radius >= WAVE_MAX_R) {
            wave.inactive = true;
            console.log('inactive');
          }
        }
      };


      el.addEventListener('mousedown', function(evt) {
        var wave = {
          'isPointerDown': true,
          'tDown': 0,
          'tUp': 0,
          'pointerDown': window.performance.now(),
          'pointerUp': 0,
          'waveMax': 0,
          'cX': evt.clientX,
          'cY': evt.clientY
        };

        var allInactive = true;
        for (var i = 0; i < waves.length; i++) {
          if (!waves[i].inactive) {
            allInactive = false;
            break;
          }
        }
        if (allInactive) {
          waves = [wave];
          if (op) {
            op.cancel();
          }
          if (rp) {
            rp.cancel();
          }
          kf = [[0, [0]], [1, [1]]];
          function toKF(kf) {
            return kf.map(function(l) { return {offset: l[0], waveRadius: l[1].join(' ')} });
          }
          rp = el.animate(toKF(kf), {duration: 1000, easing: 'forwards'});
        } else {
          waves.push(wave);
          var time = rp.currentTime / 1000;
          var i = 0;
          while (kf[i][0] < time)
            i++
          var newKF = [];
          newKF.push([0, kf[i-1][1].map(function(x) { return x + time; })]);
          for (; i < kf.length; i++)
            newKF.push([kf[i][0] - time, kf[i][1]]);
          newKF = newKF.map(function(kf) { kf[1].push(kf[0]); return kf; });
          newKF.push([1, newKF[newKF.length - 1][1].map(function() { return 1; })]);
          kf = newKF;
          rp = el.animate(toKF(kf), {duration: 1000, easing: 'forwards'});
          console.log(JSON.stringify(kf));
        }
        el.invalidate();
      });

      el.addEventListener('mousemove', function(evt) {
        for (var i = 0; i < waves.length; i++) {
          if (waves[i]['isPointerDown']) {
            waves[i]['cX'] = evt.clientX;
            waves[i]['cY'] = evt.clientY;
          }
        }
      });

      el.addEventListener('mouseup', function(evt) {
        for (var i = 0; i < waves.length; i++) {
          if (waves[i]['isPointerDown']) {
            waves[i]['isPointerDown'] = false;
            waves[i]['pointerUp'] = window.performance.now();
            waves[i]['pointerDown'] = 0;
          }
        }
        op = el.animate([{waveOpacity: '0'}, {waveOpacity: '1'}], {duration: 1000, easing: 'forwards'});
      });
    </script>
  </body>
</html>
